/* This file is part of libtrevisan, a modular implementation of
   Trevisan's randomness extraction construction.

   Copyright (C) 2011-2012, Wolfgang Mauerer <wm@linux-kernel.net>

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with libtrevisan. If not, see <http://www.gnu.org/licenses/>. */

// Generate a list of precomputed irreducible polynomials

#include <NTL/GF2X.h>
#include <NTL/GF2XFactoring.h>
#include <NTL/tools.h>
#include <cstring>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>

#include <stdlib.h>
#include <stdio.h>

NTL_CLIENT

#define MAX_FIELD_ORDER 2048
 
void convertCharArrayToIntArray( unsigned char* s_value, int* t_value, int num_chars ) {
	
	int offset = 0;
	
	if(num_chars == 0)
		return;
		
	int highest_block_idx = (num_chars-1)/4;
	double j=highest_block_idx+1-0.25;
	
	for(int i=num_chars-1; i>=0; --i) {
		t_value[(int)j] += s_value[i] << offset;
		
		offset = (offset + 8) % 32;
		j-=0.25;
	}
}

void clearArray( int* array, int size ) {
	for(int i=0; i<size; ++i) {
		array[i] = 0;
	}
}

void printbincharpad(unsigned char* ca, unsigned int n)
{
	for(int j=0; j<n; j++) {
		char c = ca[j];
	    for (int i = 7; i >= 0; --i)
	    {
	        putchar( (c & (1 << i)) ? '1' : '0' );
	    }
	    putchar(' ');
	}
	putchar('\n');
}

void printbincharpad(int* ca, unsigned int n)
{
	for(int j=0; j<n; j++) {
		int c = ca[j];
	    for (int i = 31; i >= 0; --i)
	    {
	        putchar( (c & (1 << i)) ? '1' : '0' );
	    }
	    putchar(' ');
	}
	putchar('\n');
}

void gen_irreps_ntl() {
	stringstream ss;
	cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
	cout << "#include <NTL/GF2X.h>" << endl;
	cout << "#include <sstream>" << endl;
	cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
	cout << "NTL_CLIENT" << endl;
	cout << "void set_irrep(GF2X &P, unsigned n) {" << endl;
	cout << "stringstream ss;" << endl;
	cout << "switch (n) {" << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// This way of storage is extremely inefficient. But since
		// we're only talking about a few bytes on a big iron machine,
		// who cares...
		cout << "case " << n << ":" << endl;
		cout << "ss << \"" << P  << "\";" << endl;
		cout << "ss >> P;" << endl;
		cout << "break;" << endl;
	}

	cout << "default:" << endl;
	cout << "	cerr << \"Internal error: n out of bounds!\";" << endl;
	cout << "	exit(-1);" << endl;
	cout << "}" << endl;
	cout << "}" << endl;
}

void gen_irreps_openssl() {
	stringstream ss;
	cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
	cout << "#include <openssl/bn.h>" << endl;
	cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
	cout << "using namespace std;" << endl;
	cout << "void set_irrep(int p[], unsigned n) {" << endl;
	cout << "switch (n) {" << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// Sure, there are much more efficient ways to detect the number
		// of set bits
		cout << "case " << n << ": {" << endl;

		int lidx = 0;
		for (long i = deg(P); i >= 0; i--) {
			if (coeff(P, i) == 1)
				cout << "p[" << (lidx++) << "] = " << i << ";" << endl;
		}
		cout << "} break;" << endl;
	}

	cout << "default:" << endl;
	cout << "	cerr << \"Internal error: n out of bounds!\";" << endl;
	cout << "	exit(-1);" << endl;
	cout << "}" << endl;
	cout << "}" << endl;
}

void gen_irreps_cuda() {
	stringstream ss;
	cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
	cout << "#include \"../cuda/PolyEvalGF2nBN.cuh\"" << endl;
	cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
	cout << "using namespace std;" << endl;

	cout << "void set_irrep_cuda(sfixn p[], unsigned n) {" << endl;
	cout << "switch (n) {" << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// Sure, there are much more efficient ways to detect the number
		// of set bits
		cout << "case " << n << ": {" << endl;

		long num_bytes = NumBytes(P);
		unsigned char bytes[num_bytes];
		int bytes_as_int[(num_bytes-1)/4+1];
		clearArray(bytes_as_int, (num_bytes-1)/4+1);

		BytesFromGF2X(bytes, P, num_bytes);

		reverse(bytes, bytes+num_bytes);
		
		long offset = 0;
		long i = 0;
		
		convertCharArrayToIntArray(bytes, bytes_as_int, num_bytes);

		for(int i=0; i<(num_bytes-1)/4+1; i++) {
			cout << "	p[" << i << "] = " << bytes_as_int[i] << ";" << endl;
		}

		cout << "} break;" << endl;
	}

	cout << "default:" << endl;
	cout << "	cerr << \"Internal error: n out of bounds!\";" << endl;
	cout << "	exit(-1);" << endl;
	cout << "}" << endl;
	cout << "}" << endl;
}

void gen_irreps_cuda_for_py() {
	stringstream ss;
	cout << "# This file is auto-generated by gen_irreps.cc, don't modify" << endl;
	cout << endl;

	cout << "def set_irrep( n ):" << endl;

	cout << endl;
	cout << "\tres = 0" << endl;
	cout << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// Sure, there are much more efficient ways to detect the number
		// of set bits
		if( n == 1 )
			cout << "\tif n == " << n << ":" << endl;
		else
			cout << "\telif n == " << n << ":" << endl;

		long num_bytes = NumBytes(P);
		unsigned char bytes[num_bytes];

		BytesFromGF2X(bytes, P, num_bytes);

		reverse(bytes, bytes+num_bytes);
		
		long shift = 0;

		for( int i=num_bytes-1; i>=0; --i ) {
			cout << "\t\tres = res + (" << +bytes[i] << " << " << shift << ")" << endl;
			shift = shift + 8;
		}
	}

	cout << endl;
	cout << "\treturn res" << endl;
}

int main(int argc, char **argv) {
	if(strcmp(argv[1], "NTL") == 0) {// Any argument suffices to generate for openssl
		gen_irreps_ntl();
	} else if(strcmp(argv[1], "CUDA") == 0) {
		gen_irreps_cuda();
	} else if(strcmp(argv[1], "CUDA_PY") == 0) {
		gen_irreps_cuda_for_py();
	} else {
		gen_irreps_openssl();
	}

	return 0;
}
